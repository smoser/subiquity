#!/bin/bash
# This file is part of subiquity. See LICENSE file for license information.
#
# shellcheck disable=2015,2016,2039,2162,2166

set -u
set -f

VERBOSITY=0
KEEP=true
CONTAINER=""
DEFAULT_WAIT_MAX=30
TEMP_D=""
_APT_UPDATED=false

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }
errorrc() { local r=$?; error "$@" "ret=$r"; return $r; }

Usage_main() {
    cat <<EOF
Usage: ${0##*/} mode [options]

   install-deps  [--container=] [--unittest] [--build] [--run]

   run-container                [--unittest] [--build] [--run] [--artifacts]
                                [--destroy] source [name]
   wait-for-boot [--container=]
   as-user       [--container=] [--dir=] user cmd
   as-root       [--container=] [--dir=]           cmd

   add-user      [--container=] user

   git-export    [--dirty]
   git-import    [--container=] [--dir=] [--user=]

   global options:
      -v | --verbose: increase verbosity

EOF
}

bad_Usage() {
    local usage="Usage_${1}"
    shift
    $usage 1>&2
    [ $# -eq 0 ] || error "$@";
    return 1;
}

cleanup() {
    if [ -n "$CONTAINER" ]; then
        if [ "$KEEP" = "true" ]; then
            debug 1 "not deleting container '$CONTAINER'."
        else
            debug 1 "deleting container due to --destroy"
            delete_container "$CONTAINER"
        fi
    fi
	[ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

self_inside() {
    # run_self_inside(container, args)
    local name="$1"
    shift
    inside "$name" env "_container=$name" bash -s -- "$@" <"$0"
}

self_inside_with_stdin() {
    local name="$1"
    shift
    local fname="" ret=""
    fname=$(lxc exec "$name" -- sh -c \
        'x=$(mktemp) && cat > "$x" && chmod 755 "$x" && echo $x' < "$0") || {
            errorrc "failed to write to tmp file in $name"
            return
        }
    lxc exec "$name" -- env "_container=$name" "$fname" "$@"
    ret=$?
    lxc exec "$name" -- rm -f "$fname"
    return "$ret"
}

inside() {
    local name="$1"
    shift
    lxc exec "$name" -- "$@"
}

vflag() {
    [ "$VERBOSITY" = "0" ] && return
    local flag="-" i=0
    while [ $i -lt $VERBOSITY ] && i=$((i+1)); do
        flag="${flag}v"
    done
    echo "$flag"
}

get_deps() {
    local build="$1" unittest="$2" run="$3" check="${4:-}"
    local build_deps="
        make
        python3-dev
        pkg-config
        libnl-genl-3-dev
        libnl-route-3-dev
        libsystemd-dev
        libnl-3-dev
        python3-setuptools
        python-distutils-extra
    "
    local unittest_deps="
        python3-nose
        python3-coverage
    "
    local run_deps="
        python3-urwid
        python3-pyudev
        probert
        python3-yaml
        curtin
    "
    local check_deps="
        python3-flake8
        python3-pycodestyle
    "
    (
        set -f
        [ "${build:-0}" = "0" ] || echo $build_deps
        [ "${check:-0}" = "0" ] || echo $check_deps
        [ "${run:-0}" = "0" ] || echo $run_deps
        [ "${unittest:-0}" = "0" ] || echo $unittest_deps
    ) | fmt -w1 | sort -u
}

filter_installed_packages() {
    # write to stdout, a list of packages not installed locally
    local fmt='${Package} ${Version}\n'
    LC_ALL=C dpkg-query --show "--showformat=${fmt}" "$@" 2>&1 | awk '
        $0 ~ /[Nn]o packages/ {
            sub("[.]$","",$NF);
            pkgs[n]=$NF;
            n=n+1;
        }
        $2 == "" {
                pkgs[n]=$1;
                n=n+1;
        };
        END { for(p in pkgs) {printf("%s ",pkgs[p])}; printf("\n"); }' n=0
}

apt_install() {
    local needed
    needed=$(filter_installed_packages "$@")
    needed=${needed% }
    if [ -z "$needed" ]; then
        debug 1 "all $# packages were already installed."
        return 0
    fi
    debug 1 "installing $# packages (new $needed)."
    apt_get install "$@"
}

apt_get() {
    local ret=""
    if [ "$1" != "update" ] && ! $_APT_UPDATED; then
        debug 1 "updating apt"
        apt_get update >/dev/null || {
            ret=$?;
            error "failed to update apt [$ret]";
            return $ret;
        }
        _APT_UPDATED=true
    fi
    sudo DEBIAN_FRONTEND=noninteractive apt-get --quiet \
        --no-install-recommends --assume-yes "$@" </dev/null
}

Usage_install_deps() {
    cat <<EOF
install-deps [options]

    -c | --container  CONTAINER     operate inside CONTAINER
    -b | --build                    install build dependencies
    -u | --unittest                 install unittest dependencies.
    -r | --run                      install run dependencies.
EOF
}

install_deps() {
    local short_opts="bc:urv"
    local long_opts="build,container:,unittest,run,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage install_deps; return; }

    local cur="" next="" oargs=""
    oargs=( "$@" )
    local build="" unittest="" run="" container=""
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -b|--build) build="--build";;
            -c|--container) container=$next; shift;;
            -u|--unittest) unittest="--unittest";;
            -r|--run) run="--run";;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            --) shift; break;;
        esac
        shift;
    done
    if [ -z "$build" -a -z "$unittest" -a -z "$run" ]; then
        error "Must provide one of --build, --unittest or --run."
        return 1
    fi
    eval may_run_inside install-deps "${getopt_out}" || return $_RET

    local deps=""
    deps=$(get_deps "$build" "$unittest" "$run")
    apt_install $deps
}


may_run_inside() {
    # run inside container if -c|--container=
    local i="" args="" container=""
    args=( )
    local self_inside="self_inside"
    if [ "$1" = "stdin" ]; then
        self_inside="self_inside_with_stdin"
        shift
    fi
    local first="$1"
    shift
    while [ $# -gt 0 ]; do
        cur="$1"; next="${2:-}"
        case "$cur" in
            -c|--container) container="$next"; shift;;
            --container=*) container="${cur#*=}";;
            *) args[${#args[@]}]="$cur";;
        esac
        shift
    done
    [ -z "$container" ] && return 0
    debug 1 "$self_inside $container $first ${args[*]}"
    "$self_inside" "$container" ${first} "${args[@]}"
    _RET=$?
    return 1
}

Usage_run_container() {
    cat <<EOF
run-container [options] source [name]

    run a container from 'source'.
    if name is provided, the name will be used. Otherwise a
    random name will be selected.

    options:
      -u | --unittest        run unittests
      -p | --build-package   build package
      -a | --artifacts DIR   copy build/run/unittest artifacts to DIR
      -D | --destroy         destroy the container after finishing.
EOF
}

run_container() {
    local short_opts="Dpuv"
    local long_opts="build-package,destroy,unittest,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage run_container; return; }

    local cur="" next=""
    local build="" unittest="" container=""
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -b|--build-package) build="--build";;
            -D|--destroy) KEEP=false;;
            -u|--unittest) unittest="--unittest";;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            --) shift; break;;
        esac
        shift;
    done
    [ $# -eq 1 -o $# -eq 2 ] || {
        bad_Usage run_container "got $# args, exected 2"
        return
    }
    local source=$1 container=${2:-}
    if [ -z "$container" ]; then
        command -v petname >/dev/null 2>&1 || {
            error "no 'petname' command available. must provide name."
            return
        }
        container=$(petname) || { error "petname failed"; return 1; }
    fi

    if [ "${source#*:}" = "${source}" ]; then
        source="ubuntu-daily:${source}"
    fi
    lxc launch "$source" "$container" || {
        errorrc "failed lxc launch $source $container";
        return
    }

    local cflag="--container=$container"
    wait_for_boot "$cflag" || {
        errorrc "$container did not finish booting."
        return
    }

    install_deps "$cflag" ${build} ${unittest} || return

    local user="ci-user" dirty="" dir="subiquity"
    add_user "$cflag" "$user" || return
    git_push_clone  "$cflag" "--user=$user" "--dir=$dir" ${dirty:+--dirty} ||
        return

    as_user "$cflag" "--dir=$dir" "$user" -- python3 -m nose tests
}

Usage_git_push_clone() {
    cat <<EOF
git-push-clone [options] user cmd
  export the current repo and import it as USER in DIR.

  -c | --container CONTAINER    import into CONTAINER
  -u | --user      USER         import as USER
  -d | --dir       dir          import into DIR
  -D | --dirty                  apply changes in current repo to pushed repo.
EOF
}

git_push_clone() {
    local short_opts="dDc:u:v"
    local long_opts="dir:,dirty,container:,user:,verbose"
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage wait_for_boot; return; }

    local container="" user="" dir="" dirty=""
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -c|--container) container=$next; shift;;
            -u|--user) user=$next; shift;;
            -d|--dir) dir=$next; shift;;
            -D|--dirty) dirty=true;;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            --) shift; break;;
        esac
        shift;
    done

    (
    set -o pipefail
    git_export ${dirty:+--dirty} |
        git_import ${container:+"--container=$container"} \
            ${user:+"--user=$user"} ${dir:+"--dir=$dir"}
    )
}

wait_for_boot() {
    local short_opts="c:m:v"
    local long_opts="container:,max-wait:,verbose"
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage wait_for_boot; return; }

    local wtime=$DEFAULT_WAIT_MAX container="${_container:-}"
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -c|--container) container=$next; shift;;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            -m|--max-wait) wtime="$next"; shift;;
            --) shift; break;;
        esac
        shift;
    done
    eval may_run_inside wait-for-boot "${getopt_out}" || return $_RET

    local i=0 check="is_done_other" up=""
    if [ -x /usr/bin/cloud-init ]; then
        check=is_done_cloudinit
    elif [ -e /run/systemd ]; then
        check=is_done_systemd
    fi
    debug 1 "check is $check"
    while ! $check $i; do
        i=$((i+1));
        [ "$i" -ge "$wtime" ] && exit 1
        [ "${VERBOSITY}" = "0" ] || echo -n .
        sleep 1
    done
    if [ "$VERBOSITY" != "0" ]; then
        read up _ </proc/uptime
        local msg="[${container:+${container} }${i:+done after $i }"
        msg="${msg}up=$up${_RET:+ ${_RET}}]"
        debug 1 "$msg"
    fi
}

is_done_cloudinit() {
    _RET=""
    [ -e "/run/cloud-init/result.json" ]
}

is_done_systemd() {
    local s="" num="$1"
    s=$(systemctl is-system-running 2>&1);
    _RET="$? $s"
    case "$s" in
        initializing|starting) return 1;;
        *[Ff]ailed*connect*bus*)
            # warn if not the first run.
            [ "$num" -lt 5 ] ||
                error "Failed to connect to systemd bus [${_RET%% *}]";
            return 1;;
    esac
    return 0
}

is_done_other() {
    local out=""
    out=$(getent hosts ubuntu.com 2>&1)
    return
}


Usage_as_user() {
    cat <<EOF
as-user [--container=] [--dir=] user cmd

run cmd as user, optionally in container and in pwd=DIR
defaults to home dir of user.
EOF
}

as_user() {
    local short_opts="c:d:v"
    local long_opts="container:,dir:,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/} as-user" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage as_user; return; }

    local cur="" next="" container="" user="" dir=""
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -c|--container) container="$next"; shift;;
            -d|--dir) dir="$next"; shift;;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            --) shift; break;;
        esac
        shift;
    done
    if [ $# -eq 0 ]; then
        bad_Usage as_user "Expected 1 or more args, got $#"
        return
    fi
    user="$1"
    shift
    [ $# -eq 0 ] && set -- /bin/bash

    if [ -z "$container" -a "$(id -un)" = "$user" ]; then
        local sdir="$PWD"
        cd ${dir:+"${dir}"} || { errorrc "failed to cd '$dir'"; return; }
        "$@"
        cd "$sdir"
        return
    fi
    set -- sh -ec 'd="$1"; shift; cd ~ ; cd ${d:+"$d"}; exec "$@"' \
        changedir "$dir" "$@"
    if [ "$user" != "root" ]; then
        set -- sudo "--user=$user" --set-home -- "$@"
    fi
    if [ -n "$container" ]; then
        set -- lxc exec "$container" -- "$@"
    fi
    debug 2 "$*"
    "$@"
}

Usage_as_root() {
    cat <<EOF
as-root [--container=] [--dir=DIR] cmd

run cmd as root, optionally in container and in pwd=DIR
EOF
}

as_root() {
    as_user root "$@"
}

Usage_add_user() {
    cat <<EOF
add-user [--container=] user

add the user 'user'.
EOF
}

add_user() {
    local short_opts="c:hv"
    local long_opts="container:,help,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/} add-user" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage add_user; return; }

    local cur="" next="" container="${_container:-}" user="" dir=""
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -h|--help) Usage_add_user; exit 0;;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            --) shift; break;;
        esac
        shift;
    done
    if [ $# -ne 1 ]; then
        bad_Usage as_user "Expected 1 arg (user), got $#"
        return
    fi
    eval may_run_inside add-user "${getopt_out}" || return $_RET

    user="$1"
    shift

    local home="/home/$user"
    useradd "$user" --create-home "--home-dir=$home" || {
        errorrc "${container:+[${container}] }Failed to add user '$user'" \
            "in '$name'";
        return
    }
}

Usage_git_export() {
    cat <<EOF
git-export [--dirty]

export the current git dir.

Usefull in
   ${0##*/} git-export --dirty |
      ${0##*/} git-import --container=xx --user=ubuntu --dir=ci-dir
EOF
}

git_export() {
    local short_opts="Dhv"
    local long_opts="dirty,help,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/} git-export" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage git_export; return; }

    local cur="" next="" dirty=false
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -h|--help) Usage_add_user; exit 0;;
            -D|--dirty) dirty=true; shift;;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            --) shift; break;;
        esac
        shift;
    done
    if [ $# -ne 0 ]; then
        bad_Usage git_export "Expected no args, got $#"
        return
    fi
	TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
		fail "failed to make tempdir"
	trap cleanup EXIT

    gitdir=$(git rev-parse --git-dir) || {
        errorrc "Failed to get git dir in $PWD";
        return
    }
    local t=${gitdir%/*}
    case "$t" in
        */worktrees)
            [ -f "${t%worktrees}/config" ] && gitdir="${t%worktrees}";;
    esac

    # attempt to get branch name.
    commitish=$(git rev-parse --abbrev-ref HEAD) || {
        errorrc "Failed git rev-parse --abbrev-ref HEAD"
        return
    }
    if [ "$commitish" = "HEAD" ]; then
        # detached head
        commitish=$(git rev-parse HEAD) || {
            errorrc "failed git rev-parse HEAD"
            return
        }
    fi

    local local_changes=false
    if ! git diff --quiet "$commitish"; then
        # there are local changes not committed.
        local_changes=true
        if [ "$dirty" = "false" ]; then
            error "WARNING: You had uncommitted changes.  Those changes will "
            error "be put into 'ge-local-changes.diff' inside the container. "
            error "To test these changes you must pass --dirty."
        fi
    fi

    debug 1 "local_changes=$local_changes dirty=$dirty"
    local cname="" tarcmd=""
    echo "$commitish" > "${TEMP_D}/ge-commitish"
    tarcmd=( tar -cpf - -C "$gitdir" . -C "${TEMP_D}" ge-commitish )
    if [ "$local_changes" = "true" ]; then
        [ "$dirty" = "true" ] && cname="ge-apply-changes.diff" ||
            cname="ge-local-changes.diff"
        debug 2 "wrote changes to $cname."
        git diff "$commitish" > "${TEMP_D}/$cname" || {
            error "failed to get local changes"
            return 1
        }
        tarcmd=( "${tarcmd[@]}" -C "${TEMP_D}" "$cname" )
    fi

    debug 1 "collecting ${gitdir} local_changes=$local_changes dirty=$dirty."
    "${tarcmd[@]}"
}

Usage_git_import() {
    cat <<EOF
git-import  [--container=] [--dir=] [--user=]

import/extract output of git-export.
EOF
}

git_import() {
    local short_opts="c:d:hu:v"
    local long_opts="container:,dir:,help,user:,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/} git-import" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage git_import; return; }

    local cur="" next="" container="${_container:-}" user="" dir=""
    while [ $# -ne 0 ]; do
        cur="${1:-}"; next="${2:-}";
        case "$cur" in
            -h|--help) Usage_add_user; exit 0;;
            -v|--verbose) VERBOSITY=$((VERBOSITY+1));;
            -d|--dir) dir="$next"; shift;;
            -u|--user) user="$next"; shift;;
            --) shift; break;;
        esac
        shift;
    done

    [ -n "$user" ] || user="$(id -un)" ||
        { error "failed to get user."; return 1; }
    eval may_run_inside stdin git-import "${getopt_out}" || return $_RET

    if [ -n "$user" -a "$user" != "$(id -un)" ]; then
        debug 1 "${container:+[$container] }running git-import as $user " \
            "dir=$dir."
        as_user "$user" -- "$0" "git-import" "--dir=$dir"
        return
    fi

    local sdir="$PWD" out=""
    debug 1 "extracting as '$(id -un)' to '$dir' container=${container}"
    rm -Rf "$dir/" || { error "failed rm $dir"; return 1; }
    mkdir -p "$dir/.git" ||
        { error "failed create $dir/.git"; return 1; }
    cd "$dir/.git" || { error "failed cd $dir/.git"; return 1; }
    tar xpf - ||
        { error "failed extracting from stdin"; return 1; }
    local commitish=""
    read commitish < ge-commitish
    rm ge-commitish

    cd ..
    git config core.bare false
    out=$(git checkout "$commitish" 2>&1) ||
        { error "failed git checkout $commitish: $out" 1>&2; return 1; }
    out=$(git checkout . 2>&1) ||
        { error "failed git checkout .: $out" 1>&2; return 1; }

    if [ -f ".git/ge-apply-changes.diff" ]; then
        debug 2 "applying from .git/ge-apply-changes.diff"
        git apply < .git/ge-apply-changes.diff ||
            { error "failed applying changes"; return 1; }
        rm -f ".git/ge-apply-changes.diff"
    elif [ -f ".git/ge-local-changes.diff" ]; then
        debug 2 "moving local-changes into place."
        mv ".git/ge-local-changes.diff" "./ge-local-changes.diff" ||
            { error "failed moving local changes to ."; return 1; }
    fi

    cd "$dir" || { error "failed cd $dir"; return 1; }
    debug 1 "${container:+[${container}] }wrote to $dir as $user"
}

inject_cloud_init(){
    # take current cloud-init git dir and put it inside $name at
    # ~$user/cloud-init.
    local name="$1" user="$2" dirty="$3"
    local dname="cloud-init" gitdir="" commitish=""
    gitdir=$(git rev-parse --git-dir) || {
        errorrc "Failed to get git dir in $PWD";
        return
    }
    local t=${gitdir%/*}
    case "$t" in
        */worktrees)
            if [ -f "${t%worktrees}/config" ]; then
                gitdir="${t%worktrees}"
            fi
    esac

    # attempt to get branch name.
    commitish=$(git rev-parse --abbrev-ref HEAD) || {
        errorrc "Failed git rev-parse --abbrev-ref HEAD"
        return
    }
    if [ "$commitish" = "HEAD" ]; then
        # detached head
        commitish=$(git rev-parse HEAD) || {
            errorrc "failed git rev-parse HEAD"
            return
        }
    fi

    local local_changes=false
    if ! git diff --quiet "$commitish"; then
        # there are local changes not committed.
        local_changes=true
        if [ "$dirty" = "false" ]; then
            error "WARNING: You had uncommitted changes.  Those changes will "
            error "be put into 'local-changes.diff' inside the container. "
            error "To test these changes you must pass --dirty."
        fi
    fi

    debug 1 "collecting ${gitdir} ($dname) into user $user in $name."
    tar -C "${gitdir}" -cpf - . |
        inside_as "$name" "$user" sh -ec '
            dname=$1
            commitish=$2
            rm -Rf "$dname"
            mkdir -p $dname/.git
            cd $dname/.git
            tar -xpf -
            cd ..
            git config core.bare false
            out=$(git checkout $commitish 2>&1) ||
                { echo "failed git checkout $commitish: $out" 1>&2; exit 1; }
            out=$(git checkout . 2>&1) ||
                { echo "failed git checkout .: $out" 1>&2; exit 1; }
            ' extract "$dname" "$commitish"
    [ "${PIPESTATUS[*]}" = "0 0" ] || {
        error "Failed to push tarball of '$gitdir' into $name" \
            " for user $user (dname=$dname)"
        return 1
    }

    echo "local_changes=$local_changes dirty=$dirty"
    if [ "$local_changes" = "true" ]; then
        git diff "$commitish" |
            inside_as "$name" "$user" sh -exc '
                cd "$1"
                if [ "$2" = "true" ]; then
                    git apply
                else
                    cat > local-changes.diff
                fi
                ' insert_changes "$dname" "$dirty"
        [ "${PIPESTATUS[*]}" = "0 0" ] || {
            error "Failed to apply local changes."
            return 1
        }
    fi

    return 0
}

prep() {
    # we need some very basic things not present in the container.
    #  - git
    #  - tar (CentOS 6 lxc container does not have it)
    #  - python-argparse (or python3)
    local needed="" pair="" pkg="" cmd="" needed=""
    local pairs="tar:tar git:git"
    local pyexe="$1"
    get_os_info
    local py2pkg="python2" py3pkg="python3"
    case "$OS_NAME" in
        opensuse)
            py2pkg="python-base"
            py3pkg="python3-base";;
    esac

    case "$pyexe" in
        python2) pairs="$pairs python2:$py2pkg";;
        python3) pairs="$pairs python3:$py3pkg";;
    esac

    for pair in $pairs; do
        pkg=${pair#*:}
        cmd=${pair%%:*}
        command -v "$cmd" >/dev/null 2>&1 || needed="${needed} $pkg"
    done
    if [ "$OS_NAME" = "centos" -a "$pyexe" = "python2" ]; then
        python -c "import argparse" >/dev/null 2>&1 ||
            needed="${needed} python-argparse"
    fi
    needed=${needed# }
    if [ -z "$needed" ]; then
        error "No prep packages needed"
        return 0
    fi
    error "Installing prep packages: ${needed}"
    # shellcheck disable=SC2086
    set -- $needed
    install_packages "$@"
}

nose() {
    local pyexe="$1" cmd=""
    shift
    get_os_info
    if [ "$OS_NAME/$OS_VERSION" = "centos/6" ]; then
        cmd="nosetests"
    else
        cmd="$pyexe -m nose"
    fi
    ${cmd} "$@"
}


delete_container() {
    debug 1 "removing container $1 [--keep to keep]"
    lxc delete --force "$1"
}

case "${1:-}" in
    install-deps|run-container|wait-for-boot|as-user|as-root|add-user|\
    git-export|git-import|git-push-clone)
        _n="${1//-/_}"; shift; "$_n" "$@";;
    *) bad_Usage main; exit;;
esac

# vi: ts=4 expandtab
